---
layout: default
title: 1.1 Java Basics - Types, Variables & Syntax
parent: "Module 1: Java Foundations"
nav_order: 1
---

## A Crash Course in Java 🚀

Coming from JavaScript or TypeScript, you're about to enter a world that's both familiar and refreshingly different. Java brings **compile-time safety**, **explicit types**, and **structured object-orientation** that will make your backend code more predictable and maintainable.

> **Key Mindset Shift:** In JavaScript, you discover errors at runtime. In Java, you catch most errors at compile time. This trade-off of initial verbosity for long-term reliability is Java's superpower.

---

## The Fundamental Difference: Static vs Dynamic Typing

### How JavaScript Works (Dynamic Typing)

```javascript
// JavaScript - Types determined at runtime
let user = "John";
user = { name: "John", age: 30 }; // ✅ Works fine
user = 42; // ✅ Also works fine
console.log(user.name); // 💥 Runtime error if user is 42
```

### How Java Works (Static Typing)

```java
// Java - Types declared and enforced at compile time
String user = "John";
// user = 42; // ❌ Compile error! Cannot assign int to String

// If you need different types, be explicit about it
Object user = "John";
user = 42; // ✅ Now this works, but you lose type safety
```

> **TypeScript Connection:** If you've used TypeScript, Java's type system will feel familiar but more strict. Java doesn't have `any` or gradual typing - it's all or nothing!

---

## Understanding Java's Type System

Java has two categories of types that work very differently:

### 1. Primitive Types (Value Types)

Stored directly on the stack, not objects, represent simple values.

| Type      | Size    | Range                           | JS Equivalent     |
| --------- | ------- | ------------------------------- | ----------------- |
| `byte`    | 1 byte  | -128 to 127                     | `number` (subset) |
| `short`   | 2 bytes | -32,768 to 32,767               | `number` (subset) |
| `int`     | 4 bytes | -2,147,483,648 to 2,147,483,647 | `number` (subset) |
| `long`    | 8 bytes | Very large integers             | `BigInt`          |
| `float`   | 4 bytes | 6-7 decimal digits precision    | `number` (subset) |
| `double`  | 8 bytes | 15-16 decimal digits precision  | `number`          |
| `boolean` | 1 bit   | `true` or `false`               | `boolean`         |
| `char`    | 2 bytes | Single Unicode character        | `string` (len 1)  |

### 2. Reference Types (Object Types)

Stored on the heap, includes `String`, arrays, and all custom classes.

```java
// Primitives - stored as values
int age = 25;
boolean isActive = true;

// Reference types - stored as object references
String name = "John";        // String is an object!
Integer boxedAge = 25;       // Wrapper class for int
```

---

## Variable Declaration and Naming

### Basic Variable Declaration

```java
// Basic syntax: [modifiers] type variableName = value;

// Primitive variables
int age = 25;
double price = 99.99;
boolean isActive = true;
char grade = 'A';

// Reference variables
String name = "John";
Integer boxedAge = 25;

// Constants (like const in JavaScript)
final String API_KEY = "secret123";
final int MAX_USERS = 1000;

// Multiple declarations
int x = 5, y = 10, z = 15;
int a, b, c; // Declare without initialization
a = b = c = 100; // Chain assignment
```

### Java Identifier Rules

Variable, method, and class names must follow these rules:

1. **Must start with:** letter, underscore (\_), or dollar sign ($)
2. **Can contain:** letters, digits, underscores, dollar signs
3. **Cannot be:** reserved keywords (`class`, `public`, `static`, etc.)
4. **Case-sensitive:** `myVar` and `myvar` are different

### Naming Conventions

Java has strict naming conventions that you should always follow:

- **camelCase:** Variables and methods → `myVariable`, `calculateTotal()`
- **PascalCase:** Class names → `MyClass`, `UserProfile`
- **SCREAMING_SNAKE_CASE:** Constants → `MAX_VALUE`, `API_KEY`

---

## Working with Literals

Literals are fixed values written directly in your code:

```java
// Integer literals (multiple formats)
int decimal = 42;
int binary = 0b101010;      // Binary (Java 7+)
int octal = 052;            // Octal
int hex = 0x2A;             // Hexadecimal
int readable = 1_000_000;   // Underscores for readability (Java 7+)
long bigNumber = 42L;       // Long literal (L suffix)

// Floating-point literals
float pi = 3.14F;           // Float literal (F suffix required!)
double e = 2.718;           // Double is default for decimals
double scientific = 1.23e-4; // Scientific notation

// Character literals
char letter = 'A';
char unicode = '\u0041';    // Unicode escape (also 'A')
char newline = '\n';        // Escape sequences

// Boolean literals
boolean isTrue = true;
boolean isFalse = false;

// String literals
String greeting = "Hello, World!";
String multiline = "This is line 1\n" +
                   "This is line 2";    // Java doesn't have template literals
```

---

## The String Type: Special but Not Primitive

> **Important:** `String` in Java is a reference type, not a primitive. Strings are immutable - operations create new String objects!

### String Creation and Comparison

```java
String greeting = "Hello";
String name = "World";

// String concatenation creates new objects
String message = greeting + ", " + name + "!";

// String comparison - CRITICAL DIFFERENCE FROM JAVASCRIPT
String a = "hello";
String b = "hello";
String c = new String("hello");

System.out.println(a == b);       // true (string pool optimization)
System.out.println(a == c);       // false (different objects)
System.out.println(a.equals(c));  // true (same content) ✅ Always use this!
```

### Essential String Methods

```java
String text = "  Hello Java World  ";

// Basic properties
text.length();              // 18 (includes spaces)
text.charAt(7);             // 'J'
text.isEmpty();             // false

// Case operations
text.toUpperCase();         // "  HELLO JAVA WORLD  "
text.toLowerCase();         // "  hello java world  "

// Whitespace handling
text.trim();                // "Hello Java World"
text.strip();               // "Hello Java World" (Java 11+, better Unicode)

// Substring operations
text.substring(2, 7);       // "Hello" (start inclusive, end exclusive)
text.substring(7);          // "Java World  " (from index to end)

// Search and check
text.indexOf("Java");       // 8
text.contains("Java");      // true
text.startsWith("  H");     // true
text.endsWith("  ");        // true

// Replacement
text.replace(" ", "_");     // "__Hello_Java_World__"
text.replaceAll("\\s+", "_"); // "_Hello_Java_World_" (regex)

// Splitting
String csv = "apple,banana,cherry";
String[] fruits = csv.split(","); // ["apple", "banana", "cherry"]
```

---

## Type Conversion and Casting

### Automatic Widening (Implicit)

Java automatically converts smaller types to larger types:

```java
// The widening hierarchy:
// byte → short → int → long → float → double
//        char → int

int smallInt = 42;
long bigInt = smallInt;     // int automatically becomes long
double decimal = bigInt;    // long automatically becomes double
```

### Manual Narrowing (Explicit)

Going from larger to smaller types requires explicit casting:

```java
// Explicit casting with potential data loss
double pi = 3.14159;
int approximation = (int) pi;  // 3 (truncates, doesn't round!)

// Dangerous: overflow without warning
long bigValue = 2147483648L;   // Bigger than int can hold
int overflow = (int) bigValue; // -2147483648 (overflow wraps around!)

// Safe casting with bounds checking
if (bigValue <= Integer.MAX_VALUE && bigValue >= Integer.MIN_VALUE) {
    int safeValue = (int) bigValue;
}
```

### String Conversions

```java
// Converting TO String
int number = 42;
String str1 = String.valueOf(number);    // "42" (preferred)
String str2 = Integer.toString(number);  // "42" (also good)
String str3 = "" + number;               // "42" (works but not ideal)

// Converting FROM String
String numberStr = "123";
int parsed = Integer.parseInt(numberStr);         // 123
double parsedDouble = Double.parseDouble("3.14"); // 3.14

// Handle parsing errors (we'll cover exceptions later)
try {
    int invalid = Integer.parseInt("not a number");
} catch (NumberFormatException e) {
    System.out.println("Invalid number format!");
}
```

---

## Your First Complete Java Program

Let's put it all together with a practical example:

```java
public class JavaBasicsDemo {
    public static void main(String[] args) {
        System.out.println("=== Java Basics Demo ===");

        // Variable declarations
        String developerName = "Future Java Expert";
        int currentYear = 2024;
        double javaVersion = 21.0;
        boolean isLearning = true;

        // Basic output
        System.out.println("Hello, " + developerName + "!");
        System.out.printf("Learning Java %.1f in %d%n", javaVersion, currentYear);

        // Type demonstration
        System.out.println("\n=== Type Demonstrations ===");

        // Numeric operations
        int a = 10, b = 3;
        System.out.println("Integer division: " + a + " / " + b + " = " + (a / b));
        System.out.println("Floating division: " + a + " / " + b + " = " + ((double)a / b));

        // String operations
        String message = "Java";
        System.out.println("Original: " + message);
        System.out.println("Uppercase: " + message.toUpperCase());
        System.out.println("Length: " + message.length());

        // Demonstrating immutability
        String original = "Hello";
        String modified = original.concat(" World");
        System.out.println("Original after concat: " + original);  // Still "Hello"
        System.out.println("Modified string: " + modified);        // "Hello World"

        // Command line arguments
        if (args.length > 0) {
            System.out.println("Command line argument: " + args[0]);
        }

        System.out.println("\nDemo complete!");
    }
}
```

### Understanding the Structure

```java
public class JavaBasicsDemo {  // Class name must match filename!

    // The main method - entry point of your program
    // public: accessible from anywhere
    // static: belongs to the class, not instances
    // void: doesn't return a value
    // String[] args: command-line arguments
    public static void main(String[] args) {
        // All executable code goes here
    }
}
```

### Compiling and Running

1. **Save** as `JavaBasicsDemo.java` (filename must match class name exactly!)
2. **Compile:** `javac JavaBasicsDemo.java` (creates `JavaBasicsDemo.class`)
3. **Run:** `java JavaBasicsDemo` (no `.class` extension needed)

---

## Access Modifiers: Public vs Private

Java controls visibility of code elements with access modifiers:

- **`public`:** Accessible from anywhere - other classes, packages, etc.
- **`private`:** Accessible only within the same class
- **`protected`:** Accessible within the same package and subclasses (covered later)
- **Package-private** (no modifier): Accessible within the same package

```java
public class AccessDemo {
    public String publicName = "Everyone can see this";
    private int privateAge = 25;

    public static void main(String[] args) {
        AccessDemo demo = new AccessDemo();
        System.out.println(demo.publicName);  // ✅ Works
        System.out.println(demo.privateAge);  // ✅ Works (same class)
    }

    public void publicMethod() {
        // Accessible from anywhere
    }

    private void privateMethod() {
        // Only accessible within AccessDemo class
    }
}
```

---

## Common Gotchas for JavaScript Developers

### 1. Semicolons are Mandatory

```java
int x = 5  // ❌ Compile error - missing semicolon
int y = 10; // ✅ Correct
```

### 2. Case Sensitivity Everywhere

```java
string name = "John";  // ❌ 'string' doesn't exist (lowercase 's')
String name = "John";  // ✅ 'String' with capital 'S'
```

### 3. No Automatic Type Coercion

```java
String result = "The answer is " + 42;        // ✅ Works (special case)
String result = "Value: " + true;             // ✅ Works
int result = "5" + 3;                         // ❌ Compile error
```

### 4. Filename Must Match Class Name

```java
// File: MyClass.java
public class MyClass { } // ✅ Correct

// File: myclass.java
public class MyClass { } // ❌ Wrong - case mismatch
```

---

## Practice Exercise

Create a program that showcases different Java concepts:

```java
public class TypeShowcase {
    public static void main(String[] args) {
        // TODO: Create variables of all primitive types
        // TODO: Demonstrate type casting (both safe and risky)
        // TODO: Show String operations and comparison gotchas
        // TODO: Use constants and naming conventions
        // TODO: Handle a string-to-number conversion with error handling

        System.out.println("Type showcase complete!");
    }
}
```

<details>
<summary>💡 Click to see solution</summary>

```java
public class TypeShowcase {
    // Class constant
    private static final String PROGRAM_NAME = "Type Showcase";

    public static void main(String[] args) {
        System.out.println("=== " + PROGRAM_NAME + " ===\n");

        // All primitive types
        byte smallestByte = 127;
        short shortNumber = 32000;
        int regularInt = 2_000_000;     // Underscores for readability
        long bigLong = 9_000_000_000L;  // L suffix for long

        float piFloat = 3.14159F;       // F suffix for float
        double piDouble = 3.14159265359;

        boolean isJavaAwesome = true;
        char firstLetter = 'J';

        System.out.println("=== Primitive Values ===");
        System.out.printf("byte: %d, short: %d, int: %,d, long: %,d%n",
                         smallestByte, shortNumber, regularInt, bigLong);
        System.out.printf("float: %.3f, double: %.10f%n", piFloat, piDouble);
        System.out.printf("boolean: %b, char: %c%n", isJavaAwesome, firstLetter);

        // Type casting demonstration
        System.out.println("\n=== Type Casting ===");
        double precise = 9.87654;
        int truncated = (int) precise;  // Explicit narrowing
        long widened = regularInt;      // Implicit widening

        System.out.printf("%.5f truncated to int: %d%n", precise, truncated);
        System.out.printf("int %,d widened to long: %,d%n", regularInt, widened);

        // String operations
        System.out.println("\n=== String Operations ===");
        String greeting = "Hello";
        String target = "Java Developers";
        String message = greeting + ", " + target + "!";

        System.out.println("Concatenated message: " + message);
        System.out.println("Message length: " + message.length());
        System.out.println("Uppercase: " + message.toUpperCase());

        // String comparison gotcha
        String str1 = "test";
        String str2 = "test";           // String pool
        String str3 = new String("test"); // New object

        System.out.println("\n=== String Comparison Gotcha ===");
        System.out.println("str1 == str2: " + (str1 == str2));         // true (pool)
        System.out.println("str1 == str3: " + (str1 == str3));         // false (different objects)
        System.out.println("str1.equals(str3): " + str1.equals(str3)); // true (content)

        // String parsing with error handling
        System.out.println("\n=== String Parsing ===");
        String validNumber = "42";
        String invalidNumber = "not-a-number";

        try {
            int parsed1 = Integer.parseInt(validNumber);
            System.out.println("Parsed '" + validNumber + "' to int: " + parsed1);

            int parsed2 = Integer.parseInt(invalidNumber);
            System.out.println("This won't print");
        } catch (NumberFormatException e) {
            System.out.println("Failed to parse '" + invalidNumber + "': " + e.getMessage());
        }

        System.out.println("\n" + PROGRAM_NAME + " complete!");
    }
}
```

</details>

---

## Key Takeaways

> **Essential Concepts to Remember:**
>
> 1. **Static Typing:** All variables need declared types, checked at compile time
> 2. **Two Type Categories:** Primitives (values) vs References (objects)
> 3. **String Gotchas:** Always use `.equals()` for content comparison, never `==`
> 4. **Type Safety:** Explicit casting required when narrowing types
> 5. **Immutability:** Strings are immutable - operations create new objects
> 6. **Naming Conventions:** camelCase for variables, PascalCase for classes, SCREAMING_SNAKE_CASE for constants
> 7. **File Structure:** Class name must exactly match filename, everything goes in classes

---

## What's Next?

In **1.2 Control Flow & Arrays**, we'll explore:

- Conditional statements and loops (focusing on Java-specific differences)
- Array declaration, initialization, and manipulation
- Enhanced for loops and iteration patterns
- Common pitfalls when coming from JavaScript

---

{: .fs-2 }
[Next: 1.2 Control Flow & Arrays](1.2-control-flow-arrays.md){: .btn .btn-outline }
