# Operators

## Unary Arithmetic Operators

Unary arithmetic operators operate on a single operand. In Java, the primary unary arithmetic operators are:

- **Unary Plus (`+`)**: Indicates a positive value.
- **Unary Minus (`-`)**: Negates the value of the operand.

### Example

```java
int a = 5;
// or (though this redundant as numbers are positive by default)
int a = +5;
```

In this example, the unary plus operator is used to indicate that `a` is positive, which is redundant since numbers are positive by default. The unary minus operator is used to negate the value of `a`, resulting in `b` being `-5`.

```java
int a = 5;
int b = -a; // b is -5
```

## Double Unary Operators

In Java, you can also apply unary operators multiple times. For example:

```java
int a = 5;
int b = --a; // b is 4
```

In this example, the pre-decrement operator (`--a`) decreases the value of `a` by one before assigning it to `b`. As a result, `a` becomes 4, and `b` is also 4.

Placing the operator after the operand is known as postfix notation. For example:

```java
int a = 5;
int b = a--; // b is 5, a is now 4
```

### Pre-decrement vs. Post-decrement

The difference between pre-decrement (`--a`) and post-decrement (`a--`) operators is in the order of operations:

- **Pre-decrement (`--a`)**: The variable is decremented first, then its value is used in the expression.
- **Post-decrement (`a--`)**: The current value of the variable is used in the expression, then the variable is decremented.

#### Example: Pre-decrement

```java
int x = 10;
int y = --x; // x becomes 9, y is 9
```

#### Example: Post-decrement

```java
int x = 10;
int y = x--; // y is 10, x becomes 9
```

In the pre-decrement example, `x` is decremented before its value is assigned to `y`, so both `x` and `y` are 9. In the post-decrement example, the value of `x` (10) is assigned to `y` first, and then `x` is decremented to 9.

Like JavaScript, the `+` operator is overloaded in Java and is also used for string concatenation.

## Binary Arithmetic Operators

Binary arithmetic operators operate on two operands. In Java, the primary binary arithmetic operators are:

- **Addition (`+`)**: Adds two operands.
- **Subtraction (`-`)**: Subtracts the second operand from the first.
- **Multiplication (`*`)**: Multiplies two operands.
- **Division (`/`)**: Divides the first operand by the second.
- **Modulus (`%`)**: Returns the remainder of the division of the first operand by the second.

### Example

```java
int a = 5;
int b = 10;
int c = a + b; // c is 15
int d = b - a; // d is 5
int e = a * b; // e is 50
int f = b / a; // f is 2
int g = b % a; // g is 0
```

In this example, the binary operators are used to perform various arithmetic operations on the operands `a` and `b`.

## Relational Operators

Again these are similiar to JavaScript though the triple equals operator (`===`) is not present in Java because Java is a statically typed language and does not require type coercion like JavaScript to compare values.

- **Equal to (`==`)**: Checks if two values are equal.
- **Not equal to (`!=`)**: Checks if two values are not equal.
- **Greater than (`>`)**: Checks if the left operand is greater than the right.
- **Less than (`<`)**: Checks if the left operand is less than the right.
- **Greater than or equal to (`>=`)**: Checks if the left operand is greater than or equal to the right.
- **Less than or equal to (`<=`)**: Checks if the left operand is less than or equal to the right.

### Example

```java
int a = 5;
int b = 10;
boolean c = a == b; // c is false
boolean d = a != b; // d is true
boolean e = a > b;  // e is false
boolean f = a < b;  // f is true
boolean g = a >= b; // g is false
boolean h = a <= b; // h is true
```

In this example, the relational operators are used to compare the values of `a` and `b`.

### Logical Operators

Logical operators are used to combine multiple boolean expressions. In Java, the primary logical operators are:

--

- **Logical AND (`&`)**: Returns true if both operands are true (evaluates both operands).
- **Logical Short Circuit AND (`&&`)**: Returns true if both operands are true (stops evaluation if first operand is false).
- **Logical OR (`|`)**: Returns true if at least one operand is true (evaluates both operands).
- **Logical Short Circuit OR (`||`)**: Returns true if at least one operand is true (stops evaluation if first operand is true).
- **Logical NOT (`!`)**: Reverses the logical state of its operand.
- **Logical XOR (`^`)**: Returns true if one of the operands is true.

### Example

```java
boolean a = true;
boolean b = false;
boolean c = a && b; // c is false
boolean d = a || b; // d is true
boolean e = !a;     // e is false
```

Note in the following example that attempting to evaluate both operands in a logical AND operation with a single `&` or the single or `|` can lead to unexpected behavior if the first operand is false:

```java
System.out.println(false & (5 / 0 == 0));// runtime error because the and operator returns true only if both operands are true.
System.out.println(false && (5 / 0 == 0));// prints false, because the first operand is false so the second operand is not evaluated.
System.out.println(true | (5 / 0 == 0));// runtime error because the or operator returns true if at least one operand is true so the second operand can not be evaluated.
System.out.println(true || (5 / 0 == 0));// prints true, because the first operand is true so the second operand is not evaluated.
```

In Javascript

```javascript
console.log(true & (5 / 0 == 0)); // returns 0 because true is coerced to 1 and (5 / 0 == 0) is also coerced to 0, so logical AND is 1 & 0 = 0
console.log(false && 5 / 0 == 0); // prints false, because the first operand is false so the second operand is not evaluated.
console.log(true | (5 / 0 == 0)); // returns 1 because true is coerced to 1 and (5 / 0 == 0) is also coerced to 0, so the result of logical OR is 1 | 0 = 1
console.log(true || 5 / 0 == 0); // prints true, because the first operand is true so the second operand is not evaluated.
```

Therefore it is good practice to use the short-circuit operators (`&&` and `||`) in situations where the second operand may cause an error if evaluated.

In this example, the logical operators are used to combine and manipulate boolean values.

### Ternary Operator

The ternary operator works in the same way in Java as it does in JavaScript and the syntax is also similar.

The syntax for the ternary operator is:

```java
condition ? valueIfTrue : valueIfFalse
```

### Example

```java
int a = 5;
int b = 10;
int max = a > b ? a : b; // max is 10
```

```javascript
let a = 5;
let b = 10;
let max = a > b ? a : b; // max is 10
```

In this example, the ternary operator is used to find the maximum of two values, `a` and `b`. If the condition `(a > b)` is true, `max` is assigned the value of `a`; otherwise, it is assigned the value of `b`.

### Bitwise operators

<!-- TODO -->

Write something about bitwise operators when I am less tired

### Operators with integers and floating point numbers & Big Decimal types

In Java, you can use the same operators for both integer and floating-point numbers, but be aware of the differences in how they are handled.

#### Integer Operators

For integer types (e.g., `int`, `long`), the operators work as expected:

```java
int a = 5;
int b = 10;
int sum = a + b;         // sum is 15
int difference = a - b;  // difference is -5
int product = a * b;     // product is 50
int quotient = a / b;    // quotient is 0
int remainder = a % b;   // remainder is 5
```

Be aware of integer division, which truncates the decimal part:

```java
int taxiFare = 20;
int passengerCount = 3;
// If we were to do simply dividing the two integers, we would get an integer result. If each passenger paid on 6 dollars each the taxi driver would only get 18!
int unfairFarePerPassenger = taxiFare / passengerCount; // unfairFarePerPassenger is 6
// To correct this and get a precise result, we can cast the taxiFare to double. Now the taxi driver gets the full fare.
double fairFarePerPassenger = (double) taxiFare / passengerCount; // fairFarePerPassenger is 6.666666666666667
// However each passenger can not pay fractions of cents, so the better solution is to use BigDecimal and round the result.
import java.math.BigDecimal;
import java.math.RoundingMode;

BigDecimal rideFare = BigDecimal.valueOf(taxiFare).setScale(2);
BigDecimal passengerCountBigDecimal = BigDecimal.valueOf(passengerCount);
BigDecimal roundedFarePerPassenger = rideFare.divide(rideFare);

```

#### Floating Point Operators

For floating-point types (e.g., `float`, `double`), the operators also work as expected, but be cautious of precision issues:

```java
double x = 5.0;
double y = 10.0;
double sum = x + y;         // sum is 15.0
double difference = x - y;  // difference is -5.0
double product = x * y;     // product is 50.0
double quotient = x / y;    // quotient is 0.5
```

#### BigDecimal

For precise decimal arithmetic, especially with financial calculations, use `BigDecimal`:

```java
import java.math.BigDecimal;

BigDecimal a = new BigDecimal("5.00");
BigDecimal b = new BigDecimal("10.00");
BigDecimal sum = a.add(b);         // sum is 15.00
BigDecimal difference = a.subtract(b);  // difference is -5.00
BigDecimal product = a.multiply(b);     // product is 50.00
BigDecimal quotient = a.divide(b);    // quotient is 0.50
```

In this example, the `BigDecimal` class is used to perform arithmetic operations with arbitrary precision, avoiding the pitfalls of floating-point arithmetic.
