---
layout: default
title: 1.4 Object-Oriented Programming Fundamentals
parent: "Module 1: Java Foundations"
nav_order: 4
---

## Java's Object-Oriented Foundation

Java is built from the ground up as an object-oriented language. Unlike JavaScript, where OOP was added later, Java enforces OOP principles from day one. Everything in Java (except primitives) is an object, and all code must live inside classes.

{: .highlight }
**Mindset Shift:** Coming from JavaScript's flexible approach, Java's strict OOP structure might feel constraining initially, but it provides powerful tools for building large, maintainable applications.

---

## Classes and Objects: The Building Blocks

### Class Definition and Structure

```java
// A class is a blueprint for creating objects
public class Person {
    // Instance variables (fields) - represent object state
    private String name;
    private int age;
    private String email;
    private boolean isActive;

    // Class variables (static) - shared by all instances
    private static int totalPeople = 0;

    // Constants
    public static final int MIN_AGE = 0;
    public static final int MAX_AGE = 150;

    // Constructors - special methods for creating objects

    // Default constructor
    public Person() {
        this("Unknown", 0, "no-email@example.com");
    }

    // Parameterized constructor
    public Person(String name, int age, String email) {
        setName(name);      // Use setter for validation
        setAge(age);        // Use setter for validation
        setEmail(email);    // Use setter for validation
        this.isActive = true;
        totalPeople++;      // Increment class variable
    }

    // Copy constructor
    public Person(Person other) {
        this(other.name, other.age, other.email);
        this.isActive = other.isActive;
    }

    // Getter methods (accessors)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getEmail() {
        return email;
    }

    public boolean isActive() {  // Boolean getter convention
        return isActive;
    }

    // Setter methods (mutators) with validation
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Name cannot be null or empty");
        }
        this.name = name.trim();
    }

    public void setAge(int age) {
        if (age < MIN_AGE || age > MAX_AGE) {
            throw new IllegalArgumentException("Age must be between " + MIN_AGE + " and " + MAX_AGE);
        }
        this.age = age;
    }

    public void setEmail(String email) {
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("Invalid email format");
        }
        this.email = email.toLowerCase().trim();
    }

    public void setActive(boolean active) {
        this.isActive = active;
    }

    // Static methods - belong to the class
    public static int getTotalPeople() {
        return totalPeople;
    }

    public static boolean isValidAge(int age) {
        return age >= MIN_AGE && age <= MAX_AGE;
    }

    // Instance methods - behavior
    public void haveBirthday() {
        if (age < MAX_AGE) {
            age++;
            System.out.println(name + " is now " + age + " years old!");
        }
    }

    public void sendEmail(String subject, String message) {
        if (!isActive) {
            System.out.println("Cannot send email to inactive user: " + name);
            return;
        }
        System.out.printf("Email sent to %s (%s): %s%n", name, email, subject);
    }

    // Override Object methods
    @Override
    public String toString() {
        return String.format("Person{name='%s', age=%d, email='%s', active=%b}",
                           name, age, email, isActive);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Person person = (Person) obj;
        return age == person.age &&
               isActive == person.isActive &&
               Objects.equals(name, person.name) &&
               Objects.equals(email, person.email);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age, email, isActive);
    }
}
```

### Using Classes and Objects

```java
public class PersonDemo {
    public static void main(String[] args) {
        // Creating objects using different constructors
        Person person1 = new Person();  // Default constructor
        Person person2 = new Person("Alice Johnson", 25, "alice@example.com");
        Person person3 = new Person(person2);  // Copy constructor

        System.out.println("Total people created: " + Person.getTotalPeople());

        // Using objects
        person1.setName("John Doe");
        person1.setAge(30);
        person1.setEmail("john@example.com");

        // Accessing object state
        System.out.println("Person 1: " + person1.toString());
        System.out.println("Person 2: " + person2);  // toString() called automatically

        // Using instance methods
        person2.haveBirthday();
        person2.sendEmail("Welcome", "Welcome to our platform!");

        // Static method calls
        System.out.println("Is age 25 valid? " + Person.isValidAge(25));

        // Object comparison
        System.out.println("person2 equals person3: " + person2.equals(person3));
    }
}
```

---

## The Four Pillars of OOP

### 1. Encapsulation: Data Hiding and Protection

Encapsulation is about bundling data and methods together while controlling access to the internal state.

```java
public class BankAccount {
    // Private fields - encapsulated data
    private String accountNumber;
    private double balance;
    private String accountHolder;
    private boolean isActive;

    // Constructor
    public BankAccount(String accountNumber, String accountHolder, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolder = accountHolder;
        this.balance = initialBalance >= 0 ? initialBalance : 0;
        this.isActive = true;
    }

    // Controlled access through public methods
    public double getBalance() {
        return isActive ? balance : 0;  // Only show balance if account is active
    }

    public String getAccountNumber() {
        // Return masked account number for security
        return "****" + accountNumber.substring(accountNumber.length() - 4);
    }

    public boolean deposit(double amount) {
        if (!isActive) {
            System.out.println("Cannot deposit to inactive account");
            return false;
        }

        if (amount <= 0) {
            System.out.println("Deposit amount must be positive");
            return false;
        }

        balance += amount;
        logTransaction("DEPOSIT", amount);
        return true;
    }

    public boolean withdraw(double amount) {
        if (!isActive) {
            System.out.println("Cannot withdraw from inactive account");
            return false;
        }

        if (amount <= 0) {
            System.out.println("Withdrawal amount must be positive");
            return false;
        }

        if (amount > balance) {
            System.out.println("Insufficient funds");
            return false;
        }

        balance -= amount;
        logTransaction("WITHDRAWAL", amount);
        return true;
    }

    // Private helper method - implementation detail
    private void logTransaction(String type, double amount) {
        System.out.printf("[%s] %s: $%.2f | Balance: $%.2f%n",
                         accountNumber, type, amount, balance);
    }

    // Package-private method for bank administration
    void closeAccount() {
        this.isActive = false;
        System.out.println("Account " + accountNumber + " has been closed");
    }
}
```

### 2. Inheritance: Building on Existing Classes

Inheritance allows creating new classes based on existing ones, promoting code reuse.

```java
// Base class (superclass)
public class Vehicle {
    // Protected fields - accessible to subclasses
    protected String brand;
    protected String model;
    protected int year;
    protected double price;

    // Constructor
    public Vehicle(String brand, String model, int year, double price) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.price = price;
    }

    // Methods that can be inherited
    public void displayInfo() {
        System.out.printf("%d %s %s - $%.2f%n", year, brand, model, price);
    }

    public void start() {
        System.out.println(brand + " " + model + " is starting...");
    }

    public void stop() {
        System.out.println(brand + " " + model + " is stopping...");
    }

    // Method that subclasses might want to override
    public double calculateInsurance() {
        return price * 0.05;  // 5% of vehicle value
    }

    // Getters
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public int getYear() { return year; }
    public double getPrice() { return price; }
}

// Derived class (subclass)
public class Car extends Vehicle {
    private int doors;
    private String fuelType;
    private boolean isAutomatic;

    // Constructor calls superclass constructor
    public Car(String brand, String model, int year, double price,
               int doors, String fuelType, boolean isAutomatic) {
        super(brand, model, year, price);  // Call parent constructor
        this.doors = doors;
        this.fuelType = fuelType;
        this.isAutomatic = isAutomatic;
    }

    // Override parent method
    @Override
    public void displayInfo() {
        super.displayInfo();  // Call parent method
        System.out.printf("  Doors: %d, Fuel: %s, Automatic: %b%n",
                         doors, fuelType, isAutomatic);
    }

    // Override insurance calculation
    @Override
    public double calculateInsurance() {
        double baseInsurance = super.calculateInsurance();
        // Sports cars cost more to insure
        if (doors == 2) {
            baseInsurance *= 1.5;
        }
        return baseInsurance;
    }

    // Car-specific methods
    public void honk() {
        System.out.println("Beep beep!");
    }

    public void openTrunk() {
        System.out.println("Trunk opened");
    }

    // Getters for car-specific fields
    public int getDoors() { return doors; }
    public String getFuelType() { return fuelType; }
    public boolean isAutomatic() { return isAutomatic; }
}

// Another derived class
public class Motorcycle extends Vehicle {
    private int engineSize;
    private boolean hasSidecar;

    public Motorcycle(String brand, String model, int year, double price,
                     int engineSize, boolean hasSidecar) {
        super(brand, model, year, price);
        this.engineSize = engineSize;
        this.hasSidecar = hasSidecar;
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.printf("  Engine: %dcc, Sidecar: %b%n", engineSize, hasSidecar);
    }

    @Override
    public double calculateInsurance() {
        // Motorcycles have different insurance calculation
        return super.calculateInsurance() * 0.8;  // 20% less than base
    }

    // Motorcycle-specific methods
    public void wheelie() {
        System.out.println("Performing wheelie!");
    }

    public int getEngineSize() { return engineSize; }
    public boolean hasSidecar() { return hasSidecar; }
}
```

### 3. Polymorphism: One Interface, Multiple Forms

Polymorphism allows objects of different types to be treated as objects of a common base type.

```java
public class VehicleDemo {
    public static void main(String[] args) {
        // Array of Vehicle references, but different object types
        Vehicle[] vehicles = {
            new Car("Toyota", "Camry", 2023, 25000, 4, "Gasoline", true),
            new Motorcycle("Harley-Davidson", "Street 750", 2023, 8000, 750, false),
            new Car("Porsche", "911", 2023, 100000, 2, "Gasoline", false)
        };

        // Polymorphism in action - same method call, different behavior
        System.out.println("=== Vehicle Information ===");
        for (Vehicle vehicle : vehicles) {
            vehicle.displayInfo();  // Calls overridden method based on actual object type
            System.out.printf("Insurance: $%.2f%n", vehicle.calculateInsurance());
            vehicle.start();

            // Type checking and casting
            if (vehicle instanceof Car) {
                Car car = (Car) vehicle;  // Safe casting
                car.honk();
                if (car.getDoors() == 2) {
                    System.out.println("This is a sports car!");
                }
            } else if (vehicle instanceof Motorcycle) {
                Motorcycle bike = (Motorcycle) vehicle;
                bike.wheelie();
            }

            vehicle.stop();
            System.out.println("---");
        }

        // Method that works with any Vehicle
        calculateTotalInsurance(vehicles);
    }

    // Polymorphic method - accepts any Vehicle subtype
    public static void calculateTotalInsurance(Vehicle[] vehicles) {
        double total = 0;
        for (Vehicle vehicle : vehicles) {
            total += vehicle.calculateInsurance();  // Polymorphic call
        }
        System.out.printf("Total insurance cost: $%.2f%n", total);
    }
}
```

### 4. Abstraction: Hiding Implementation Details

#### Abstract Classes

Abstract classes define common structure but leave some methods for subclasses to implement.

```java
// Abstract class - cannot be instantiated directly
public abstract class Animal {
    protected String name;
    protected int age;
    protected double weight;

    public Animal(String name, int age, double weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }

    // Concrete methods - implemented in base class
    public void eat() {
        System.out.println(name + " is eating");
    }

    public void sleep() {
        System.out.println(name + " is sleeping");
    }

    // Abstract methods - must be implemented by subclasses
    public abstract void makeSound();
    public abstract void move();
    public abstract String getSpecies();

    // Template method pattern
    public void dailyRoutine() {
        System.out.println("=== " + name + "'s Daily Routine ===");
        eat();
        move();
        makeSound();
        sleep();
    }

    // Getters
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getWeight() { return weight; }
}

// Concrete subclass
public class Dog extends Animal {
    private String breed;

    public Dog(String name, int age, double weight, String breed) {
        super(name, age, weight);
        this.breed = breed;
    }

    @Override
    public void makeSound() {
        System.out.println(name + " barks: Woof woof!");
    }

    @Override
    public void move() {
        System.out.println(name + " runs around the yard");
    }

    @Override
    public String getSpecies() {
        return "Canis lupus familiaris (" + breed + ")";
    }

    // Dog-specific method
    public void fetch() {
        System.out.println(name + " fetches the ball");
    }

    public String getBreed() { return breed; }
}

public class Bird extends Animal {
    private double wingspan;
    private boolean canFly;

    public Bird(String name, int age, double weight, double wingspan, boolean canFly) {
        super(name, age, weight);
        this.wingspan = wingspan;
        this.canFly = canFly;
    }

    @Override
    public void makeSound() {
        System.out.println(name + " chirps: Tweet tweet!");
    }

    @Override
    public void move() {
        if (canFly) {
            System.out.println(name + " flies through the sky");
        } else {
            System.out.println(name + " walks on the ground");
        }
    }

    @Override
    public String getSpecies() {
        return "Aves";
    }

    public void preen() {
        System.out.println(name + " preens its feathers");
    }

    public double getWingspan() { return wingspan; }
    public boolean canFly() { return canFly; }
}
```

#### Interfaces: Pure Abstraction

Interfaces define contracts that classes must fulfill.

```java
// Interface - pure abstraction
public interface Drawable {
    // All methods are implicitly public and abstract
    void draw();
    void erase();

    // Default method (Java 8+)
    default void highlight() {
        System.out.println("Highlighting the drawable object");
    }

    // Static method (Java 8+)
    static void printDrawingInfo() {
        System.out.println("Drawing utilities v2.0");
    }

    // Constants (implicitly public, static, final)
    String DEFAULT_COLOR = "Black";
    int MAX_SIZE = 1000;
}

// Interface for resizable objects
public interface Resizable {
    void resize(double factor);
    double getArea();
}

// Interface for colorable objects
public interface Colorable {
    void setColor(String color);
    String getColor();
}

// Class implementing multiple interfaces
public class Rectangle implements Drawable, Resizable, Colorable {
    private double width;
    private double height;
    private String color;
    private boolean isVisible;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
        this.color = Drawable.DEFAULT_COLOR;
        this.isVisible = false;
    }

    // Implementing Drawable interface
    @Override
    public void draw() {
        System.out.printf("Drawing %s rectangle (%.1f x %.1f)%n", color, width, height);
        isVisible = true;
    }

    @Override
    public void erase() {
        System.out.println("Erasing rectangle");
        isVisible = false;
    }

    // Implementing Resizable interface
    @Override
    public void resize(double factor) {
        width *= factor;
        height *= factor;
        System.out.printf("Rectangle resized by factor %.2f%n", factor);
    }

    @Override
    public double getArea() {
        return width * height;
    }

    // Implementing Colorable interface
    @Override
    public void setColor(String color) {
        this.color = color;
        System.out.println("Rectangle color changed to " + color);
    }

    @Override
    public String getColor() {
        return color;
    }

    // Rectangle-specific methods
    public double getWidth() { return width; }
    public double getHeight() { return height; }
    public boolean isVisible() { return isVisible; }

    @Override
    public String toString() {
        return String.format("Rectangle[%.1fx%.1f, %s, visible=%b]",
                           width, height, color, isVisible);
    }
}

// Another implementation
public class Circle implements Drawable, Resizable, Colorable {
    private double radius;
    private String color;
    private boolean isVisible;

    public Circle(double radius) {
        this.radius = radius;
        this.color = Drawable.DEFAULT_COLOR;
        this.isVisible = false;
    }

    @Override
    public void draw() {
        System.out.printf("Drawing %s circle (radius %.1f)%n", color, radius);
        isVisible = true;
    }

    @Override
    public void erase() {
        System.out.println("Erasing circle");
        isVisible = false;
    }

    @Override
    public void resize(double factor) {
        radius *= factor;
        System.out.printf("Circle resized by factor %.2f%n", factor);
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public void setColor(String color) {
        this.color = color;
        System.out.println("Circle color changed to " + color);
    }

    @Override
    public String getColor() {
        return color;
    }

    public double getRadius() { return radius; }
    public boolean isVisible() { return isVisible; }

    @Override
    public String toString() {
        return String.format("Circle[radius=%.1f, %s, visible=%b]",
                           radius, color, isVisible);
    }
}
```

---

## Advanced OOP Concepts

### Composition vs Inheritance

```java
// Composition example - "HAS-A" relationship
public class Engine {
    private String type;
    private int horsepower;
    private boolean isRunning;

    public Engine(String type, int horsepower) {
        this.type = type;
        this.horsepower = horsepower;
        this.isRunning = false;
    }

    public void start() {
        isRunning = true;
        System.out.println(type + " engine started (" + horsepower + "hp)");
    }

    public void stop() {
        isRunning = false;
        System.out.println(type + " engine stopped");
    }

    public boolean isRunning() { return isRunning; }
    public String getType() { return type; }
    public int getHorsepower() { return horsepower; }
}

// Car using composition instead of inheritance for Engine
public class ModernCar {
    private String brand;
    private String model;
    private Engine engine;  // HAS-A engine (composition)
    private List<String> features;

    public ModernCar(String brand, String model, Engine engine) {
        this.brand = brand;
        this.model = model;
        this.engine = engine;  // Composition
        this.features = new ArrayList<>();
    }

    public void start() {
        System.out.println("Starting " + brand + " " + model);
        engine.start();  // Delegate to composed object
    }

    public void stop() {
        engine.stop();
        System.out.println(brand + " " + model + " stopped");
    }

    public void addFeature(String feature) {
        features.add(feature);
    }

    public void displayInfo() {
        System.out.printf("%s %s with %s%n", brand, model, engine.getType());
        System.out.println("Features: " + String.join(", ", features));
    }

    // Getters
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public Engine getEngine() { return engine; }
    public List<String> getFeatures() { return new ArrayList<>(features); }
}
```

### Inner Classes and Nested Classes

```java
public class OuterClass {
    private String outerField = "Outer field";
    private static String staticOuterField = "Static outer field";

    // Instance inner class
    public class InnerClass {
        private String innerField = "Inner field";

        public void display() {
            System.out.println("Inner class accessing: " + outerField);  // Can access outer fields
            System.out.println("Inner field: " + innerField);
        }
    }

    // Static nested class
    public static class StaticNestedClass {
        private String nestedField = "Nested field";

        public void display() {
            System.out.println("Static nested class accessing: " + staticOuterField);
            // System.out.println(outerField);  // ‚ùå Cannot access non-static outer fields
            System.out.println("Nested field: " + nestedField);
        }
    }

    // Method with local inner class
    public void methodWithLocalClass() {
        final String localVar = "Local variable";

        // Local inner class
        class LocalInnerClass {
            public void display() {
                System.out.println("Local inner class accessing: " + outerField);
                System.out.println("Local variable: " + localVar);  // Must be final or effectively final
            }
        }

        LocalInnerClass local = new LocalInnerClass();
        local.display();
    }

    // Anonymous inner class example
    public void demonstrateAnonymousClass() {
        // Anonymous class implementing Runnable
        Runnable task = new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous class executing: " + outerField);
            }
        };

        task.run();
    }
}
```

---

## Practical Examples and Design Patterns

### Example 1: Complete Library Management System

```java
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

// Abstract base class for library items
public abstract class LibraryItem {
    protected String id;
    protected String title;
    protected String author;
    protected boolean isAvailable;
    protected LocalDate dueDate;

    public LibraryItem(String id, String title, String author) {
        this.id = id;
        this.title = title;
        this.author = author;
        this.isAvailable = true;
        this.dueDate = null;
    }

    // Abstract methods
    public abstract double calculateLateFee(LocalDate currentDate);
    public abstract int getMaxLoanDays();
    public abstract String getItemType();

    // Common methods
    public boolean checkout(LocalDate checkoutDate) {
        if (!isAvailable) {
            return false;
        }

        isAvailable = false;
        dueDate = checkoutDate.plusDays(getMaxLoanDays());
        return true;
    }

    public void returnItem() {
        isAvailable = true;
        dueDate = null;
    }

    public boolean isOverdue(LocalDate currentDate) {
        return dueDate != null && currentDate.isAfter(dueDate);
    }

    // Getters
    public String getId() { return id; }
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public boolean isAvailable() { return isAvailable; }
    public LocalDate getDueDate() { return dueDate; }

    @Override
    public String toString() {
        return String.format("%s: %s by %s [%s]",
                           getItemType(), title, author,
                           isAvailable ? "Available" : "Checked out");
    }
}

// Concrete implementations
public class Book extends LibraryItem {
    private String genre;
    private int pages;

    public Book(String id, String title, String author, String genre, int pages) {
        super(id, title, author);
        this.genre = genre;
        this.pages = pages;
    }

    @Override
    public double calculateLateFee(LocalDate currentDate) {
        if (!isOverdue(currentDate)) {
            return 0.0;
        }

        long daysOverdue = ChronoUnit.DAYS.between(dueDate, currentDate);
        return daysOverdue * 0.50;  // $0.50 per day
    }

    @Override
    public int getMaxLoanDays() {
        return 21;  // 3 weeks for books
    }

    @Override
    public String getItemType() {
        return "Book";
    }

    public String getGenre() { return genre; }
    public int getPages() { return pages; }
}

public class DVD extends LibraryItem {
    private int duration;  // in minutes
    private String rating;

    public DVD(String id, String title, String director, int duration, String rating) {
        super(id, title, director);  // director goes to author field
        this.duration = duration;
        this.rating = rating;
    }

    @Override
    public double calculateLateFee(LocalDate currentDate) {
        if (!isOverdue(currentDate)) {
            return 0.0;
        }

        long daysOverdue = ChronoUnit.DAYS.between(dueDate, currentDate);
        return daysOverdue * 1.00;  // $1.00 per day for DVDs
    }

    @Override
    public int getMaxLoanDays() {
        return 7;  // 1 week for DVDs
    }

    @Override
    public String getItemType() {
        return "DVD";
    }

    public int getDuration() { return duration; }
    public String getRating() { return rating; }
    public String getDirector() { return author; }  // Convenience method
}

// Library management class
public class Library {
    private List<LibraryItem> items;
    private Map<String, LibraryItem> itemsById;

    public Library() {
        this.items = new ArrayList<>();
        this.itemsById = new HashMap<>();
    }

    public void addItem(LibraryItem item) {
        items.add(item);
        itemsById.put(item.getId(), item);
    }

    public LibraryItem findItem(String id) {
        return itemsById.get(id);
    }

    public boolean checkoutItem(String itemId, LocalDate checkoutDate) {
        LibraryItem item = findItem(itemId);
        if (item == null) {
            System.out.println("Item not found: " + itemId);
            return false;
        }

        if (item.checkout(checkoutDate)) {
            System.out.println("Checked out: " + item.getTitle());
            return true;
        } else {
            System.out.println("Item not available: " + item.getTitle());
            return false;
        }
    }

    public void returnItem(String itemId, LocalDate returnDate) {
        LibraryItem item = findItem(itemId);
        if (item == null) {
            System.out.println("Item not found: " + itemId);
            return;
        }

        double lateFee = item.calculateLateFee(returnDate);
        item.returnItem();

        System.out.println("Returned: " + item.getTitle());
        if (lateFee > 0) {
            System.out.printf("Late fee: $%.2f%n", lateFee);
        }
    }

    public void displayAllItems() {
        System.out.println("=== Library Inventory ===");
        for (LibraryItem item : items) {
            System.out.println(item);
        }
    }

    public List<LibraryItem> getOverdueItems(LocalDate currentDate) {
        return items.stream()
                   .filter(item -> item.isOverdue(currentDate))
                   .collect(Collectors.toList());
    }
}
```

### Example 2: E-commerce System with Multiple Design Patterns

```java
// Strategy Pattern for Payment Processing
public interface PaymentStrategy {
    boolean processPayment(double amount);
    String getPaymentType();
}

public class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String expiryDate;
    private String cvv;

    public CreditCardPayment(String cardNumber, String expiryDate, String cvv) {
        this.cardNumber = cardNumber;
```

[Previous: 1.3 Control Flow & Arrays](1.3-methods-scope.md){: .btn .btn-outline }
[Next: 1.5 Advanced OOP Concepts](1.5-advanced-oop.md){: .btn .btn-outline }
